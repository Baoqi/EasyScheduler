<template>
  <div class="sdc-stage-model">
    <x-select
      v-model="selectedStageId"
      :disabled="isDetails"
      filterable
      @on-change="_handleStageChanged"
      style="width: 520px;">
      <x-option
        v-for="item in stageList"
        :key="_getId(item)"
        :value="_getId(item)"
        :label="item.label">
        <span class="default-option-class">
          <img v-bind:src="'data:image/jpeg;base64,'+item.iconBase64" width="20" height="20"/>
          <span style="padding: 3px">{{item.label}}</span>
        </span>
      </x-option>
    </x-select>
    <div class="list-model"  v-if="configValue[0]">
      <div class="table-box">
        <table>
          <tr>
            <th width="30">
              <span>{{$t('#')}}</span>
            </th>
            <th width="80">
              <span>{{$t('Parameter Group')}}</span>
            </th>
            <th width="180">
              <span>{{$t('Parameter Name')}}</span>
            </th>
            <th width="25">
              <span>I</span>
            </th>
            <th width="60">
              <span>{{$t('Parameter Type')}}</span>
            </th>
            <th>
              <span>{{$t('Parameter Value')}}</span>
            </th>
          </tr>
          <tr v-for="(item, $index) in configDefinition" :key="$index" v-if="configElementVisible[$index]===true">
            <td>
              <span>{{$index + 1}}</span>
            </td>
            <td>
              <span>{{item.group}}</span>
            </td>
            <td>
              <span v-bind:class="{required: item.required}">{{item.label}}</span>
            </td>
            <td>
              <i v-if="item.description.length > 0" class="i ans-icon-notice-empty" data-toggle="tooltip" :title="item.description"></i>
            </td>
            <td>
              <span>{{item.type}}</span>
            </td>
            <td>
              <span v-if="item.type==='STRING' || item.type==='CREDENTIAL' || item.type==='CHARACTER'">
                <x-input
                  :disabled="isDetails"
                  type="text"
                  v-model="configValue[$index].value"
                  @on-change="_handleConfigValueChanged_TEXT($event, $index)"
                  style="width: 200px;">
                </x-input>
              </span>
              <span v-if="item.type==='TEXT'">
                <x-input
                  :disabled="isDetails"
                  type="textarea"
                  resize="none"
                  :autosize="{minRows:2}"
                  v-model="configValue[$index].value"
                  @on-change="_handleConfigValueChanged_TEXT($event, $index)"
                  style="width: 200px;">
                </x-input>
              </span>
              <span v-if="item.type==='NUMBER'">
                <x-input
                  :disabled="isDetails"
                  type="text"
                  v-model="configValue[$index].value"
                  @on-change="_handleConfigValueChanged_TEXT($event, $index)"
                  style="width: 200px;">
                </x-input>
              </span>
              <span v-if="item.type==='BOOLEAN'">
                <x-switch v-model="configValue[$index].value" @on-change="_handleConfigValueChanged_TEXT($event, $index)" :disabled="isDetails"></x-switch>
              </span>
              <span v-if="item.type==='MODEL' && item.model.modelType==='VALUE_CHOOSER'">
                <x-select
                  v-model="configValue[$index].value"
                  @on-change="_handleConfigValueChanged_VALUE_CHOOSER($event, $index)"
                  :disabled="isDetails"
                  style="width: 200px;">
                  <x-option
                    v-for="(vitem, $vindex) in item.model.values" :key="$vindex"
                    :value="vitem"
                    :label="item.model.labels[$vindex]">
                  </x-option>
                </x-select>
              </span>
              <span style="background-color: yellow;" v-if="item.type !== 'STRING' && item.type !== 'CREDENTIAL' && item.type !== 'CHARACTER' && item.type !=='TEXT' && item.type !=='NUMBER' && item.type !=='BOOLEAN' && !(item.type === 'MODEL' && item.model.modelType === 'VALUE_CHOOSER')">
                  {{JSON.stringify(configValue[$index].value)}}
              </span>
            </td>
          </tr>
        </table>
      </div>
    </div>
  </div>
</template>
<script>
  import _ from 'lodash'
  import disabledState from '@/module/mixin/disabledState'
  export default {
    name: 'sdc-stage',
    data () {
      return {
        // selected ID
        selectedStageId: {},
        configDefinition: Array,
        configValue: Array,
        configElementVisible: Array
      }
    },
    mixins: [disabledState],
    props: {
      stageList: Array,
      stageWithConfig: Object,
    },
    methods: {
      /**
       * return sqlType
       */
      _handleStageChanged(val) {
        let foundStage = _.filter(this.stageList, (stage) => {
          return this._getId(stage) === val.value;
        })[0]

        this.$emit('on-stageChange', {
          "name": foundStage.name,
          "libraryName": foundStage.libraryName,
          "stageVersion": foundStage.stageVersion,
          "configValue": JSON.parse(foundStage.defaultConfigurationJson)
        })

        this.$nextTick(() => {
          this._updateCurrentConfig()
        })
      },
      _getId(stage) {
        if (stage) {
          return stage.name + '|' + stage.libraryName
        } else {
          stage
        }
      },
      _updateCurrentConfig() {
        if (this.stageWithConfig !== null && this.stageWithConfig.name !== null) {
          let self = this
          let foundStage = _.filter(this.stageList, function (stage) {
            return stage.name === self.stageWithConfig.name && stage.libraryName === self.stageWithConfig.libraryName;
          })[0];
          if (foundStage) {
            this.configDefinition = JSON.parse(foundStage.configurationDefinitionJson)
            this.configValue = this.stageWithConfig.configValue
            this._refreshVisiable()
          }
        }
      },
      _refreshVisiable() {
        let self = this
        let newVisibles = _.map(self.configDefinition, (cd) => {
          if (!_.isEmpty(cd.dependsOnMap)) {
            return _.every(cd.dependsOnMap, (varray, k) => {
              let foundDepCurrentValue = _.find(self.configValue, (x) => x.name === k)
              if (!_.isNil(foundDepCurrentValue)) {
                return _.includes(varray, foundDepCurrentValue.value)
              } else {
                return true;
              }
            })
          } else {
            return true
          }
        })

        _.map(_.range(0, newVisibles.length), (i) => {
          if (newVisibles[i] !== self.configElementVisible[i]) {
            Vue.set(self.configElementVisible, i, newVisibles[i])
          }
        })
      },
      _handleConfigValueChanged_TEXT(newVal, $index) {
        this._onConfigChanged(newVal, $index)
      },
      _handleConfigValueChanged_VALUE_CHOOSER(newVal, $index) {
        this._onConfigChanged(newVal.value, $index)
      },
      _onConfigChanged(newVal, $index) {
        let keyName = this.configValue[$index].name
        Vue.set(this.configValue, $index, {"name": keyName, "value": newVal})
        this._refreshVisiable()
        this.$nextTick(() => {
          this.$emit('on-stageChange', {
            "name": this.stageWithConfig.name,
            "libraryName": this.stageWithConfig.libraryName,
            "stageVersion": this.stageWithConfig.stageVersion,
            "configValue": this.configValue
          })
        })
      }
    },
    watch: {
    },
    created () {
      this.$nextTick(() => {
        if (this.stageWithConfig !== null && this.stageWithConfig.name !== null) {
          this.selectedStageId = this._getId(this.stageWithConfig)
        } else {
          this.selectedStageId = {}
        }
        this._updateCurrentConfig()
      })
    },
    mounted () {
    }
  }
</script>

<style lang="scss" rel="stylesheet/scss">
  span.required:before {
    content:"* ";
    color: red;
  }
</style>
